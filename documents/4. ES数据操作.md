# 第一步：创建测试索引（定义数据的“房子”和“房间”）

首先，我们创建一个名为 my_test_index 的索引。这里的关键是设置

- "number_of_shards": 2：将数据分成 2 个主分片（想象成 2 个主要房间，P0 和 P1）。

- "number_of_replicas": 1：为每个主分片创建 1 个副本分片（即每个房间有 1 个一模一样的备用房间）。
  在 Postman 中执行以下：

```
http://localhost:9200/my_test_index

body:

{
  "settings": {
    "number_of_shards": 2,
    "number_of_replicas": 1
  },
  "mappings": {
    "properties": {
      "title": { "type": "text" },
      "content": { "type": "text" },
      "view_count": { "type": "integer" },
      "timestamp": { "type": "date" }
    }
  }
}
```

# 第二步：立即查看分片分布（核心验证）

请仔细观察输出结果，它会是类似这样的表格：

```
http://localhost:9200/_cat/shards/my_test_index?v&h=index,shard,prirep,state,node

index         shard prirep state   node      store
my_test_index 0     p      STARTED es-data2   249b
my_test_index 0     r      STARTED es-data1   249b
my_test_index 1     p      STARTED es-data1 10.3kb
my_test_index 1     r      STARTED es-data2 10.3kb
```

这就是您要的“数据主分片和副本分片”的直观展示！

- shard：分片编号（0 和 1）。

- prirep：p 代表 主分片 (Primary)，r 代表 副本分片 (Replica)。

- node：这个分片目前存放在哪个容器节点上。

- 关键规律：同一个分片（例如 shard 0）的主分片 (p) 和副本分片 (r) 绝对不会在同一个节点上。这是保证高可用的铁律。

# 第三步：写入测试数据（向“房间”里放入“物品”

让我们向索引中插入几条文档（数据）。

```
post:

http://localhost:9200/my_test_index/_doc

body:

 {
  "title": "理解分片概念",
  "content": "今天成功部署了ES集群，并看到了分片分布。",
  "view_count": 100,
  "timestamp": "2024-05-14T10:00:00"
}


{
  "title": "集群高可用测试",
  "content": "接下来我们将模拟节点故障，观察副本如何接管。",
  "view_count": 50,
  "timestamp": "2024-05-14T10:05:00"
}
```

# 第四步：查询数据与搜索

根据 id 搜索文档

```
http://localhost:9200/my_test_index/_doc/101?pretty
```

搜索素有文档

```
http://localhost:9200/my_test_index/_search?pretty

```

在 title 和 content 中搜索“集群”

```
POST:

http://localhost:9200/my_test_index/_search?pretty

body:
{
  "query": {
    "multi_match": {
      "query": "集群",
      "fields": ["title", "content"]
    }
  }
}
```

# 第五步：模拟节点故障，体验高可用

docker-compose stop es-data1
等待约 10-20 秒，让集群检测到故障并完成重新分配。

再次查看分片状态：

```
http://localhost:9200/_cat/shards/my_test_index?v&h=index,shard,prirep,state,node

index         shard prirep state      node      store
my_test_index 0     p      STARTED    es-data2   249b
my_test_index 0     r      UNASSIGNED
my_test_index 1     p      STARTED    es-data2 10.3kb
my_test_index 1     r      UNASSIGNED

```

## 观察神奇的变化：

原先在 es-data1 上的那个主分片的状态可能会变成 UNASSIGNED（未分配）或消失。

而原先在另一个节点（比如 es-data2）上的那个对应的副本分片 (r)，它的 prirep 会变成 p，state 保持 STARTED！

这意味着：副本分片自动升级成了新的主分片，数据没有丢失，集群仍然可以继续提供读写服务！ 这就是高可用的真谛。

# 如果想彻底停止并清理整个集群环境（容器、网络、数据卷）

docker-compose down -v

# 查询 数据在什么分片上

```
http://localhost:9200/my_test_index/_search_shards?routing=RUX9F5sBYXprecghEydR&pretty

{
    "nodes": {
        "SPShjsExTt2Zr4171HrMHA": {
            "name": "es-data1",
            "ephemeral_id": "h_Glv_Z-QpinGkOeeP6MvA",
            "transport_address": "172.22.0.4:9300",
            "external_id": "es-data1",
            "attributes": {
                "transform.config_version": "10.0.0",
                "ml.config_version": "11.0.0",
                "xpack.installed": "true"
            },
            "roles": [
                "data"
            ],
            "version": "8.11.0",
            "min_index_version": 7000099,
            "max_index_version": 8500003
        },
        "8DC8H-C9TSCYge22SyWPRQ": {
            "name": "es-data2",
            "ephemeral_id": "aWXV9MqmQber0f7fdXfebw",
            "transport_address": "172.22.0.5:9300",
            "external_id": "es-data2",
            "attributes": {
                "xpack.installed": "true",
                "ml.config_version": "11.0.0",
                "transform.config_version": "10.0.0"
            },
            "roles": [
                "data"
            ],
            "version": "8.11.0",
            "min_index_version": 7000099,
            "max_index_version": 8500003
        }
    },
    "indices": {
        "my_test_index2": {}
    },
    "shards": [
        [
            {
                "state": "STARTED",
                "primary": true,
                "node": "8DC8H-C9TSCYge22SyWPRQ",
                "relocating_node": null,
                "shard": 0,
                "index": "my_test_index2",
                "allocation_id": {
                    "id": "zGx17U8NS26A53v-4_soDg"
                },
                "relocation_failure_info": {
                    "failed_attempts": 0
                }
            },
            {
                "state": "STARTED",
                "primary": false,
                "node": "SPShjsExTt2Zr4171HrMHA",
                "relocating_node": null,
                "shard": 0,
                "index": "my_test_index2",
                "allocation_id": {
                    "id": "Zld-ar6QR8WCEcl_z6hdRQ"
                },
                "relocation_failure_info": {
                    "failed_attempts": 0
                }
            }
        ]
    ]
}
```

## 结果分析

节点信息（nodes）

```
"nodes": {
  "SPShjsExTt2Zr4171HrMHA": {  # 节点ID
    "name": "es-data1",         # 节点名称
    "roles": ["data"],          # 节点角色（数据节点）
    "transport_address": "172.22.0.4:9300"
  },
  "8DC8H-C9TSCYge22SyWPRQ": {
    "name": "es-data2",
    "roles": ["data"],
    "transport_address": "172.22.0.5:9300"
  }
}
```

你有 2 个数据节点：es-data1 和 es-data2。
分片分布（shards）

```
"shards": [
  [  # 这是分片0（shard 0）的主副本组
    {
      "state": "STARTED",      # 分片状态（已启动）
      "primary": true,         # 这是主分片（primary shard）
      "node": "8DC8H-C9TSCYge22SyWPRQ",  # 所在节点：es-data2
      "shard": 0,              # 分片编号
      "index": "my_test_index2"
    },
    {
      "state": "STARTED",      # 分片状态（已启动）
      "primary": false,        # 这是副本分片（replica shard）
      "node": "SPShjsExTt2Zr4171HrMHA",  # 所在节点：es-data1
      "shard": 0,              # 分片编号
      "index": "my_test_index2"
    }
  ]
]
```

# 如果我建的集群副本数量 多余 es 的 数据节点

```
PUT

http://localhost:9201/my_test_index2
{
  "settings": {
    "number_of_shards": 1,
    "number_of_replicas": 2
  },
  "mappings": {
    "properties": {
      "title": { "type": "text" },
      "content": { "type": "text" },
      "view_count": { "type": "integer" },
      "timestamp": { "type": "date" }
    }
  }
}
```

查看分片分布

```
http://localhost:9200/_cat/shards/my_test_index2?v&h=index,shard,prirep,state,node,store&s=shard,prirep
index          shard prirep state      node     store
my_test_index2 0     p      STARTED    es-data2  227b
my_test_index2 0     r      STARTED    es-data1  227b
my_test_index2 0     r      UNASSIGNED

```

会有一个副本分片无处安放

# 如何确认 数据要写入到几号分片中呢

shared = hash(routing) % number_of_primary_shards
![alt text](<../截图/2. es数据，写入分片原理.png>)

# 读取数据

![alt text](<../截图/3. es取数据原理.png>)
