# 线上环境，需要集成 log 设置

完成 .net -> fluentd -> Elastic search -> Kibana 这个流程

# 首先遇到容器无法启动问题

```
D:\Code\1.microservice\2.netcore_microservice_userService\DeployApps>docker-compose up -d
time="2026-01-07T20:35:47+08:00" level=warning msg="D:\\Code\\1.microservice\\2.netcore_microservice_userService\\DeployApps\\docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion"
[+] Running 0/6
 - Container api-gateway    Starting                                                                                              6.3s
 - Container user-identity  Starting                                                                                              6.3s
 - Container user-api       Starting                                                                                              6.3s
 - Container recommend-api  Starting                                                                                              6.3s
 - Container project-api    Starting                                                                                              6.3s
 - Container contact-api    Starting                                                                                              6.3s
Error response from daemon: failed to create task for container: failed to initialize logging driver: dial tcp: lookup fluentd: i/o timeout
```

# 开始想办法

1. 怀疑网络问题
   于是改了 network 设置
   networks: - microservices-network
   都换成统一的这个网络了，其实原本就是 都一样的网络

2. 测试链接与否

```
# 进入 api-gateway 容器测试连接
docker exec -it api-gateway /bin/bash

# 在容器内执行以下命令：
# 测试 DNS 解析
nslookup fluentd

# 测试端口连接（如果没有 nc，可以使用其他方法）
apt-get update && apt-get install -y netcat
nc -zv fluentd 24224

# 或者使用 curl 测试
curl -v telnet://fluentd:24224
```

结果，都是链接的

3. documents\8. Serilog.md 回到此文档找出当时成功的案例
   因为此过程，需要所有容器 重新创建，所以又遇到很多问题
   .net -> fluentd -> Elastic search -> Kibana
   ES 其实是很关键的一步，ES 问题必须首先解决掉，并且能够启动成功
   这里是新建容器时候，必须把持久化的数据删掉(这么做其实不正确，可以作为遗留问题，需要后续再看)，再去启动 es 容器，
   docker-compose up -d es-master es-data1 es-data

## 此处有遗留问题

4. 发现 localhost 是好用的
   docker run -d -p 8080:80 -p 8444:444 --name serilog_structured_test --log-driver=fluentd --log-opt fluentd-address=localhost:24224 helloworld:serilog-structured
   然后尝试修改成 localhost

```
  api-gateway:
    image: registry.cn-hangzhou.aliyuncs.com/microsoftservice/api.gateway:v1
    container_name: api-gateway
    ports:
      - "5108:80"
      - "7030:447"
    logging:
      driver: "fluentd"
      options:
        fluentd-address: "localhost:24224"
        tag: "prod.api-gateway"
    networks:
      - microservices-network
    restart: unless-stopped
```

这样其实可以工作，只是代码没有集成 serilog，所 fluentd 有解析异常

5. 代码中添加 Serilog 配置

# log 内容解释

```
{
  "Timestamp": "2026-01-10T07:33:32.1462557+08:00",  // 控制方式：Serilog框架自动生成，使用ISO 8601格式
  "Level": "Information",                            // 控制方式：由日志记录方法决定（Log.Information/Error/Debug等）
  "MessageTemplate": "[2026/1/10 7:33:32] Get 方法被调用",  // 控制方式：您传递给日志方法的原始字符串
  "RenderedMessage": "[2026/1/10 7:33:32] Get 方法被调用",   // 控制方式：Serilog处理结构化参数后的最终消息
  "TraceId": "76226c03fc6ab44c67c6dd525f037864",      // 控制方式：ASP.NET Core自动生成（Activity.TraceId）
  "SpanId": "a6b118300167fcb3",                       // 控制方式：ASP.NET Core自动生成（Activity.SpanId）
  "Properties": {
    "SourceContext": "Contact.API.Controllers.ContactController",  // 控制方式：ASP.NET Core自动添加（当使用ILogger<T>时）
    "ActionId": "a1e22f19-3555-4e49-95f3-c93a5537c779",          // 控制方式：ASP.NET Core MVC框架自动添加
    "ActionName": "Contact.API.Controllers.ContactController.Get (Contact.API)",  // 控制方式：ASP.NET Core MVC框架自动添加
    "RequestId": "0HNIFQTL04VUE:00000001",                      // 控制方式：ASP.NET Core自动添加（HttpContext.TraceIdentifier）
    "RequestPath": "/api/contacts",                            // 控制方式：ASP.NET Core自动添加（HttpContext.Request.Path）
    "ConnectionId": "0HNIFQTL04VUE",                          // 控制方式：ASP.NET Core自动添加（HttpContext.Connection.Id）
    "MachineName": "DESKTOP-SVPKUF8",                         // 控制方式：由 .Enrich.WithMachineName() 添加（Serilog丰富器）
    "ThreadId": 12,                                           // 控制方式：由 .Enrich.WithThreadId() 添加（Serilog丰富器）
    "Application": "User.API",                                // 控制方式：由 .Enrich.WithProperty("Application", "User.API") 添加（需修正为Contact.API）
    "Environment": "Development",                             // 控制方式：由 .Enrich.WithProperty("Environment", environment) 添加，值来自HostingEnvironment.EnvironmentName
    "Assembly": "Contact.API",                                // 控制方式：由 .Enrich.WithProperty("Assembly", assemblyName) 添加，值来自Assembly.GetEntryAssembly()?.GetName().Name
    "Version": "1.0.0.0",                                     // 控制方式：由 .Enrich.WithProperty("Version", assemblyVersion) 添加，值来自Assembly.GetEntryAssembly()?.GetName().Version?.ToString()
    "CorrelationId": "00-76226c03fc6ab44c67c6dd525f037864-a6b118300167fcb3-01"  // 控制方式：由CorrelationIdEnricher类添加，值来自Activity.Current?.Id
  }
}
```

```
// 在SerilogConfiguration.ConfigureSerilog方法中
loggerConfiguration
    .Enrich.WithProperty("Application", applicationName)     // 对应"Application"字段
    .Enrich.WithProperty("Assembly", assemblyName)           // 对应"Assembly"字段
    .Enrich.WithProperty("Version", assemblyVersion)         // 对应"Version"字段
    .Enrich.WithProperty("Environment", environment)         // 对应"Environment"字段
    .Enrich.WithMachineName()                               // 对应"MachineName"字段
    .Enrich.WithThreadId()                                  // 对应"ThreadId"字段
    .Enrich.WithCorrelationId();                            // 对应"CorrelationId"字段
```

# Fluentd 配置继续解读

```
# 使用 copy 插件同时输出到 Elasticsearch 和 stdout
<match **>
  @type copy
  <store>
    @type elasticsearch
    host es-master
    port 9200
    logstash_format true
    logstash_prefix fluentd
    template_name "fluentd_template"
    template_overwrite true
    flush_interval 5s
    # 重试机制
    request_timeout 30s
    reload_connections false
    reconnect_on_error true
    reload_on_failure true
  </store>
  <store>
    @type stdout
    @id stdout_output
  </store>
</match>
```

## 解读

@type stdout 表示将日志输出到 Fluentd 容器自身的控制台/stdout
当您在 Fluentd 配置中使用 @type stdout 时，日志会被输出到：

Fluentd 容器自己的控制台输出

查看输出的 log
docker logs fluentd --tail 20

排查问题：当 Elasticsearch 没有收到数据时，先检查 Fluentd 是否收到了数据
