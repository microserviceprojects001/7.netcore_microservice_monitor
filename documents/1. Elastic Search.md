# 日志监控

比较成熟的就是 ELK，其中 E 就是 Elastic Search

# 1. Elastic Search

## 能做什么

一、为什么微服务需要 Elasticsearch？
微服务架构将单体应用拆分为多个独立、松耦合的服务，每个服务拥有自己的私有数据库。这带来了优势，也引入了新问题：

跨服务搜索困难：例如，用户想搜索“去年购买过某品牌手机的用户”，数据分散在“订单服务”、“用户服务”、“商品服务”的数据库中。直接在数据库层做跨库 JOIN 查询几乎不可能，且性能极差。

全文检索能力弱：传统关系型数据库（如 MySQL）的 LIKE 语句性能低下，无法支持复杂的全文检索（如分词、同义词、相关性评分）。

数据分析与聚合瓶颈：对海量业务数据进行实时聚合分析（如月度销售报表、用户行为分析）会给业务数据库带来巨大压力，影响在线事务处理性能。

集中化日志与监控需求：微服务实例众多，日志分散在各处。排查问题需要快速收集、搜索和分析所有服务的日志、指标和链路追踪数据。

Elasticsearch 正是解决这些问题的利器。

## 具备哪些优势

## 分布式集群特性

# 安装 (只是一个单容器形势)

需要先去填写镜像地址
https://github.com/AbelLiuKai/docker_image_pusher/blob/main/images.txt

然后就会默认进入到阿里云的镜像仓库里

docker login --username=abelliu001 registry.cn-hangzhou.aliyuncs.com
docker pull registry.cn-hangzhou.aliyuncs.com/abelcontainer/elasticsearch:8.11.0

```
docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e "ES_JAVA_OPTS=-Xms512m -Xmx512m" -e "xpack.security.enabled=false" -e "xpack.security.transport.ssl.enabled=false" registry.cn-hangzhou.aliyuncs.com/abelcontainer/elasticsearch:8.11.0
```

阿里云上安装会直接导致机器 内存沾满，机器无法使用，所有在本地实体机安装的 容器

http://localhost:9200/

# 发送 post 请求

我现在看哈，网上老师在用 http://localhost:9200/website/blog/aaaa 这个地址发送 post 请求 {
"Title": "aaa",
"text":"test",
"date":"2026/01/01"
} 这是怎么一回事啊

1. 旧版 URL 结构解析
   http://localhost:9200/索引名/类型名/文档 ID
   website：索引。类似于关系型数据库中的“表”或“数据库”。它用于存放某一类文档。

blog：类型。在旧版中，一个索引下可以定义不同的类型。但在 Elasticsearch 7.x 及以后的版本中，这个概念已被废弃，一个索引只允许有一个类型，且固定为 \_doc。

aaaa：文档 ID。指定这个文档的唯一标识符。如果 ID 为 aaaa 的文档不存在，则创建它；如果存在，则更新它。

请求体（JSON）：这就是文档的实际内容。

2. 当前版本（8.x）的正确操作方式
   由于“类型”概念已废弃，现在标准的操作方式是 省略类型名，直接使用 \_doc。
   方法一：指定文档 ID（与老师例子效果一致）

```
curl -X POST “http://localhost:9200/website/_doc/aaaa“ -H ‘Content-Type: application/json‘ -d ‘
{
  “Title“: “aaa“,
  “text“: “test“,
  “date“: “2026/01/01“
}
‘
```

方法二：让 ES 自动生成文档 ID（更常用）

```
curl -X POST “http://localhost:9200/website/_doc“ -H ‘Content-Type: application/json‘ -d ‘
{
  “Title“: “aaa“,
  “text“: “test“,
  “date“: “2026/01/01“
}
‘
```

注意 URL 中没有指定 ID（/website/\_doc）。

Elasticsearch 会自动生成一个全局唯一的 ID（如 \_id”: “1a2b3c4d“）。响应中会返回它。
如果成功，会返回类似这样的响应，其中 ”\_id”: “1a2b3c4d“ 就是系统生成的 ID：
